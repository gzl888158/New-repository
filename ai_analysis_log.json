import time
import json
import requests
import numpy as np
from datetime import datetime

# ==================== 配置参数 ====================
OKX_API_KEY = ""          # GitHub Secrets 会覆盖此值
OKX_SECRET_KEY = ""       # GitHub Secrets 会覆盖此值
OKX_PASSPHRASE = ""       # GitHub Secrets 会覆盖此值
# 多币种配置（可自行添加其他币种）
INST_IDS = [
    "BTC-USDT-SWAP",
    "ETH-USDT-SWAP",
    "SOL-USDT-SWAP"
]
BAR = "15m"               # K线周期
LIMIT = 20                # 拉取最近20根K线
LOG_FILE = "multi_coin_ai_log.json"  # 多币种日志文件

# ==================== 欧易 API 接口 ====================
OKX_BASE_URL = "https://www.okx.com"
OKX_CANDLES_URL = f"{OKX_BASE_URL}/api/v5/market/candles"

# ==================== 工具函数 ====================
def get_okx_candles(inst_id, bar, limit):
    """拉取欧易K线数据"""
    params = {
        "instId": inst_id,
        "bar": bar,
        "limit": limit
    }
    try:
        response = requests.get(OKX_CANDLES_URL, params=params, timeout=10)
        data = response.json()
        if data["code"] == "0" and len(data["data"]) > 0:
            # 格式化K线数据：时间戳、开、高、低、收、成交量
            candles = []
            for item in data["data"]:
                candles.append({
                    "ts": int(item[0]),
                    "open": float(item[1]),
                    "high": float(item[2]),
                    "low": float(item[3]),
                    "close": float(item[4]),
                    "vol": float(item[5])
                })
            return sorted(candles, key=lambda x: x["ts"])  # 按时间正序排列
        else:
            print(f"拉取{inst_id}K线失败: {data['msg']}")
            return []
    except Exception as e:
        print(f"拉取{inst_id}K线异常: {str(e)}")
        return []

def calculate_macd(close_prices, fastperiod=12, slowperiod=26, signalperiod=9):
    """计算MACD指标"""
    ema_fast = np.convolve(close_prices, np.ones(fastperiod)/fastperiod, mode='valid')
    ema_slow = np.convolve(close_prices, np.ones(slowperiod)/slowperiod, mode='valid')
    macd_line = ema_fast - ema_slow[-len(ema_fast):]
    signal_line = np.convolve(macd_line, np.ones(signalperiod)/signalperiod, mode='valid')
    histogram = macd_line[-len(signal_line):] - signal_line
    return macd_line, signal_line, histogram

def analyze_trend(candles):
    """趋势分析：多头/空头/震荡"""
    if len(candles) < 5:
        return "震荡", "K线数据不足"
    
    recent_close = [c["close"] for c in candles[-5:]]
    # 计算涨幅
    max_price = max(recent_close)
    min_price = min(recent_close)
    change_rate = (max_price - min_price) / min_price * 100

    if recent_close[-1] > recent_close[0] and change_rate > 1:
        return "多头", f"近5根K线上涨{change_rate:.2f}%"
    elif recent_close[-1] < recent_close[0] and change_rate > 1:
        return "空头", f"近5根K线下跌{change_rate:.2f}%"
    else:
        return "震荡", f"近5根K线振幅{change_rate:.2f}%"

def analyze_volume(candles):
    """成交量异动检测"""
    if len(candles) < 10:
        return "正常", "成交量数据不足"
    
    recent_vol = [c["vol"] for c in candles[-5:]]
    history_vol = [c["vol"] for c in candles[:-5]]
    avg_recent = np.mean(recent_vol)
    avg_history = np.mean(history_vol)

    if avg_recent > avg_history * 1.5:
        return "放量", f"近5根K线成交量放大{((avg_recent/avg_history)-1)*100:.2f}%"
    elif avg_recent < avg_history * 0.5:
        return "缩量", f"近5根K线成交量缩小{((1-avg_recent/avg_history))*100:.2f}%"
    else:
        return "正常", "成交量无明显异动"

def generate_trade_signal(trend, macd_signal, volume_status):
    """生成交易信号：buy/sell/hold"""
    # 多头+MACD金叉+放量 → 买入
    if trend == "多头" and macd_signal == "金叉" and volume_status == "放量":
        return "buy"
    # 空头+MACD死叉+放量 → 卖出
    elif trend == "空头" and macd_signal == "死叉" and volume_status == "放量":
        return "sell"
    # 其他情况 → 持有
    else:
        return "hold"

# ==================== 多币种主分析函数 ====================
def analyze_single_coin(inst_id):
    """分析单个币种"""
    # 1. 拉取K线数据
    candles = get_okx_candles(inst_id, BAR, LIMIT)
    if not candles:
        return {
            "instId": inst_id,
            "trend": "未知",
            "macdSignal": "无",
            "volumeStatus": "未知",
            "analysis": "K线数据拉取失败",
            "signal": "hold",
            "lastPrice": 0
        }
    
    # 2. 提取收盘价和成交量
    close_prices = np.array([c["close"] for c in candles])
    vol_data = [c["vol"] for c in candles]

    # 3. 趋势分析
    trend, trend_desc = analyze_trend(candles)

    # 4. MACD分析
    macd_line, signal_line, histogram = calculate_macd(close_prices)
    if len(macd_line) < 2 or len(signal_line) < 2:
        macd_desc = "MACD数据不足"
        macd_signal = "无"
    else:
        # 判断金叉/死叉
        if macd_line[-1] > signal_line[-1] and macd_line[-2] < signal_line[-2]:
            macd_signal = "金叉"
            macd_desc = "MACD金叉形成，短期看涨"
        elif macd_line[-1] < signal_line[-1] and macd_line[-2] > signal_line[-2]:
            macd_signal = "死叉"
            macd_desc = "MACD死叉形成，短期看跌"
        else:
            macd_signal = "无"
            macd_desc = "MACD无明显交叉"

    # 5. 成交量分析
    volume_status, volume_desc = analyze_volume(candles)

    # 6. 生成交易信号
    trade_signal = generate_trade_signal(trend, macd_signal, volume_status)

    # 7. 生成分析结论
    analysis_conclusion = f"{trend_desc} | {macd_desc} | {volume_desc}"

    return {
        "instId": inst_id,
        "trend": trend,
        "macdSignal": macd_signal,
        "volumeStatus": volume_status,
        "analysis": analysis_conclusion,
        "signal": trade_signal,
        "lastPrice": candles[-1]["close"]
    }

def main():
    print(f"开始多币种AI分析 - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    # 多币种分析结果汇总
    multi_coin_result = {
        "updateTime": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        "updateTimestamp": int(time.time() * 1000),
        "coins": []
    }

    # 循环分析每个币种
    for inst_id in INST_IDS:
        coin_result = analyze_single_coin(inst_id)
        multi_coin_result["coins"].append(coin_result)
        print(f"{inst_id} 分析完成，信号: {coin_result['signal']}")

    # 保存多币种日志文件
    with open(LOG_FILE, "w", encoding="utf-8") as f:
        json.dump(multi_coin_result, f, ensure_ascii=False, indent=4)
    
    print(f"多币种AI分析完成，日志已保存至: {LOG_FILE}")

if __name__ == "__main__":
    main()